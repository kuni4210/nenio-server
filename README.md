## 프로젝트 소개
- 선택형 질문 기반의 소통을 간편하게 지원하는 커뮤니티 앱
- 데이터 구조: https://www.erdcloud.com/d/CtfGuXbAeLDgStj6H
- api 문서: http://110.165.17.28:3000/api

## 사용 기술
Backend
- Language: javascript(es6), typescript
- Framework: Nest.js
- Database: MySQL (TypeORM)
- Etc: git
  
Devops
- AWS (ec2, s3)

## 문제 해결
- 이 프로젝트는 특정 API의 동작 시 권한 확인 및 사용자 정보 조회를 위해 Firebase Authentication을 사용합니다.
이를 위해 처음에는 각 컨트롤러마다 Firebase 인증 코드를 직접 작성하여 관리했습니다. 이 방식은 권한 확인과 사용자 정보 활용을 위해 조회한 사용자의 유형(userType)을 확인하여 권한을 부여하고, 권한에 맞지 않은 경우 ForbiddenException 오류를 반환했습니다. 그러나 이 방식은 가독성이 좋지 않고, 사용자 권한 관리가 어려웠습니다. 이를 개선하기 위해 파이어베이스 인증 후 역할 기반의 권한 검사를 쉽게 수행할 수 있도록 Roles 데코레이터를 사용하여 역할 정보를 메타데이터로 설정하고, 파이어베이스 권한 확인 후 역할 정보를 확인하는 것을 FirebaseAuthGuard 모듈로 직접 구현했습니다. 개선 후 컨트롤러에 @Roles(UserRole.ADMIN); @UseGuards(FirebaseAuthGuard); 라고 작성하면 권한을 제한할 수 있게 되었습니다.
- 트랜잭션 관리의 문제를 해결하기 위해 데코레이터와 인터셉터를 도입하여 중앙 집중화된 트랜잭션 관리 방식을 구현했습니다. 기존에는 각 API마다 트랜잭션 시작, 커밋, 롤백을 수동으로 처리해야 했으며, 이로 인해 코드 중복과 일관성 부족 문제가 발생했습니다. 이를 개선하기 위해 TransactionInterceptor를 통해 트랜잭션의 시작과 종료를 자동화하고, @TransactionManager 데코레이터를 사용하여 컨트롤러에서 간편하게 트랜잭션 객체를 주입받을 수 있도록 했습니다. 이 방식은 비즈니스 로직과 트랜잭션 관리 로직을 분리하여 코드 가독성을 높이고, 예외 발생 시 자동으로 롤백을 수행함으로써 데이터 무결성을 보장합니다. 또한, 새로운 API에 트랜잭션을 적용할 때 인터셉터와 데코레이터만 선언하면 되므로 확장성과 유지보수성이 크게 향상되었습니다. 이러한 개선으로 인해 트랜잭션 관리가 간소화되고, 프로젝트의 안정성과 효율성이 크게 강화되었습니다.


- 프로젝트에는 question, option, user 엔티티가 있습니다. 특정 사용자가 질문에 참여할 때, answer 엔티티에는 question과 option 그리고 user의 ID를 저장합니다. 처음 설계는 데이터 모니터링 관점에서 좋을 것 같았지만, 일반 질문 목록 조회나 본인이 참여한 질문 목록 조회 등을 작성할 때 answer 엔티티와의 조인이 추가로 필요하게 되어 비효율적으로 느껴졌습니다. 따라서 question과 user, 그리고 option과 user를 각각 연결하는 조인 테이블을 만드는 방향으로 설계를 개선하였고, 쿼리도 조인을 한번씩 줄이는 방향으로 수정할 수 있었습니다. 이러한 변경으로 인해 데이터베이스 쿼리를 더 효율적으로 작성하고, 조인 작업을 최소화하여 성능을 향상시킬 수 있습니다.
